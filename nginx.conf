worker_processes auto;
                error_log /var/log/nginx/error.log info;
                pid /var/run/nginx.pid;
                
                events {
                worker_connections 1024;
                use epoll;
                multi_accept on;
        }
                
                http {
                include /usr/local/openresty/nginx/conf/mime.types;
                default_type application/octet-stream;
          
          # Логирование
                log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                '$status $body_bytes_sent "$http_referer" '
                '"$http_user_agent" "$http_x_forwarded_for" '
                'jwt_valid=$jwt_valid jwt_user=$jwt_user_login';
                access_log /var/log/nginx/access.log main;
          
          # Основные настройки
                sendfile on;
                tcp_nopush on;
                tcp_nodelay on;
                keepalive_timeout 65;
                types_hash_max_size 2048;
          
          # Размеры буферов
                client_max_body_size 10m;
          
          # Gzip сжатие
                gzip on;
                gzip_vary on;
                gzip_min_length 1024;
                gzip_types text/plain text/css text/xml text/javascript
                application/javascript application/xml+rss application/json;
          
          # Lua настройки
                lua_package_path "/usr/local/openresty/nginx/lua/?.lua;/usr/local/openresty/lualib/?.lua;;";
                
                server {
                listen 7000;
                server_name localhost;
          
          # Переменные для JWT должны быть в блоке server
                set $jwt_valid "";
                set $jwt_user_login "";
                set $jwt_error "";
          
          # Безопасность заголовков
                add_header X-Frame-Options "SAMEORIGIN" always;
                add_header X-XSS-Protection "1; mode=block" always;
                add_header X-Content-Type-Options "nosniff" always;
                add_header Referrer-Policy "no-referrer-when-downgrade" always;
                add_header Content-Security-Policy "default-src 'self' 'unsafe-inline' 'unsafe-eval'" always;
          
          # =========================================================
          # ПРОСТАЯ ЛОГИКА АУТЕНТИФИКАЦИИ
          # =========================================================
          
          # ФОРУМ - для авторизованных пользователей
                location /forum {
                access_by_lua_block {
                    
                -- Выполняем аутентификацию
                local jwt_auth_ok, jwt_auth = pcall(require, "jwt-auth")
                if not jwt_auth_ok then
        ngx.log(ngx.ERR, "Failed to load jwt-auth module: ", jwt_auth)
                    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end
                
                local auth_ok, auth_result = pcall(jwt_auth.authenticate)
                if not auth_ok or ngx.var.jwt_valid ~= "true" then
                    return ngx.redirect("/public/auth.html")
                end
            }
            
            proxy_pass http://127.0.0.1:8000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Authorization $http_authorization;
            proxy_set_header X-User-Login $jwt_user_login;
            proxy_pass_request_headers on;
        }
        
        # Старая приватная статика (оставляем для совместимости)
        location /private/ {
            access_by_lua_block {
                local jwt_auth_ok, jwt_auth = pcall(require, "jwt-auth")
                if not jwt_auth_ok then
                    ngx.log(ngx.ERR, "Failed to load jwt-auth module: ", jwt_auth)
                    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end
                
                local auth_ok, auth_result = pcall(jwt_auth.authenticate)
                if not auth_ok or ngx.var.jwt_valid ~= "true" then
                    return ngx.redirect("/public/auth.html")
                    # ngx.status = ngx.HTTP_UNAUTHORIZED
                    # ngx.header["Content-Type"] = "application/json"
                    # ngx.say('{"message": "Необходима авторизация", "login": "", "token": ""}')
                    # ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
            }
            
            alias /usr/share/nginx/static_authenticated/;
            expires 1h;
            add_header Cache-Control "private, no-transform";

            location ~* \.html$ {
                add_header Cache-Control "no-cache, no-store, must-revalidate";
                add_header Pragma "no-cache";
                add_header Expires "0";
            }
        }
        
        # Защищённые эндпоинты API
        location /api/ {
            access_by_lua_block {
                local jwt_auth_ok, jwt_auth = pcall(require, "jwt-auth")
                if not jwt_auth_ok then
                    ngx.log(ngx.ERR, "Failed to load jwt-auth module: ", jwt_auth)
                    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end
                
                local auth_ok, auth_result = pcall(jwt_auth.authenticate)
                if not auth_ok or ngx.var.jwt_valid ~= "true" then
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say('{"message": "Необходима авторизация", "login": "", "token": ""}')
                    ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
            }
            
            proxy_pass http://localhost:8012/api/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-User-Login $jwt_user_login;
            proxy_pass_request_headers on;
        }

        # Главная страница, перенаправляет на форум или авторизацию
location = / {
    content_by_lua_block {
        ngx.log(ngx.INFO, "=== ROOT LOCATION ACCESSED ===")
        ngx.log(ngx.INFO, "Initial variables: jwt_valid=", ngx.var.jwt_valid, ", jwt_user_login=", ngx.var.jwt_user_login)
        
        local jwt_auth_ok, jwt_auth = pcall(require, "jwt-auth")
        if not jwt_auth_ok then
            ngx.log(ngx.ERR, "Failed to load jwt-auth module: ", jwt_auth)
            ngx.exec("/public/auth.html")
            return
        end
        
        local auth_ok, auth_result = pcall(jwt_auth.authenticate)
        
        ngx.log(ngx.INFO, "Auth result: success=", tostring(auth_ok), ", result=", tostring(auth_result))
        ngx.log(ngx.INFO, "Variables after auth: jwt_valid=", ngx.var.jwt_valid, ", jwt_user_login=", ngx.var.jwt_user_login)

        if auth_ok and ngx.var.jwt_valid == "true" then
            ngx.log(ngx.INFO, "Redirecting authenticated user to forum")
            ngx.exec("/forum")
        else
            ngx.log(ngx.INFO, "Redirecting unauthenticated user to auth page")
            ngx.exec("/public/auth.html")
        end
    }
}

        # Эндпоинты, которые не требуют аутентификации
        location = /submit-form {
            proxy_pass http://localhost:8012/auth;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
            proxy_pass_request_headers on;
            proxy_pass_request_body on;
        }

        location /public/ {
            alias /usr/share/nginx/static_public/;
        }

        location = /auth {
            proxy_pass http://localhost:8012/auth;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
            proxy_pass_request_headers on;
            proxy_pass_request_body on;
        }

        location /health {
            access_log off;
            return 200 "OK\n";
            add_header Content-Type text/plain;
        }
        
        location = /favicon.ico {
            alias /usr/share/nginx/static_public/favicon.ico;
            expires 1d;
            log_not_found off;
            access_log off;
        }
        
        # Обработка ошибок
        error_page 401 @error401;
        error_page 403 @error403;
        error_page 404 @error404;
        error_page 500 502 503 504 @error50x;

        location @error401 {
            add_header Content-Type application/json always;
            return 401 '{"message": "Необходима авторизация", "login": "", "token": ""}';
        }

        location @error403 {
            add_header Content-Type application/json always;
            return 403 '{"message": "Доступ запрещён", "login": "", "token": ""}';
        }

        location @error404 {
            add_header Content-Type application/json always;
            return 404 '{"message": "Страница не найдена", "login": "", "token": ""}';
        }

        location @error50x {
            add_header Content-Type application/json always;
            return 500 '{"message": "Внутренняя ошибка сервера", "login": "", "token": ""}';
        }
        }
        }